<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on My Blog</title>
    <link>https://jbrandhorst.com/tags/golang/index.xml</link>
    <description>Recent content in Golang on My Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <copyright>Copyright (c) 2017, Johan Brandhorst; all rights reserved. Thanks to Netlify.com for hosting my blog!</copyright>
    <atom:link href="https://jbrandhorst.com/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>GopherJS Client and gRPC Server - Introduction</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve been using &lt;a href=&#34;http://www.grpc.io/&#34;&gt;gRPC&lt;/a&gt; and &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; a lot in the last year.
At &lt;a href=&#34;https://www.cognitivelogic.com&#34;&gt;Cognitive Logic&lt;/a&gt; every one of our backend services is
implemented with Go and gRPC, and it enables us to abstract away most of the complexities
of networked micro services and keep interfaces typed and well defined using
&lt;a href=&#34;https://developers.google.com/protocol-buffers/&#34;&gt;Google protobuffers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I really enjoy using both, but sometimes I need to write a frontend to a
web server and I despise writing Javascript. So what do? Use Go of course!&lt;/p&gt;

&lt;p&gt;With &lt;a href=&#34;https://github.com/gopherjs/gopherjs&#34;&gt;GopherJS&lt;/a&gt; it&amp;rsquo;s possible to write safe
statically typed code that transpiles to Javascript. It comes with a couple of
quirks but as long as I don&amp;rsquo;t have to use Javascript I&amp;rsquo;m happy.&lt;/p&gt;

&lt;p&gt;Naturally, I want to be able to use Go and gRPC in the backend as well if I can,
and with the use of the &lt;a href=&#34;https://github.com/grpc-ecosystem/grpc-gateway&#34;&gt;gRPC HTTP Gateway&lt;/a&gt;
it becomes as simple as writing a normal gRPC service.&lt;/p&gt;

&lt;p&gt;So what are the steps required to get a GopherJS frontend client talking to a gRPC backend
seamlessly? In short:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jbrandhorst.com/post/gopherjs-client-grpc-server-1/&#34;&gt;Create the protobuf interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jbrandhorst.com/post/gopherjs-client-grpc-server-2/&#34;&gt;Implement the server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jbrandhorst.com/post/gopherjs-client-grpc-server-3/&#34;&gt;Implement the client&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jbrandhorst.com/post/gopherjs-client-grpc-server-4/&#34;&gt;Putting it all together&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you want to skip ahead, the finished example can be found on
&lt;a href=&#34;https://github.com/johanbrandhorst/gopherjs-grpc-websocket&#34;&gt;my github&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;preparation&#34;&gt;Preparation&lt;/h2&gt;

&lt;p&gt;Some structure will help organization. Let&amp;rsquo;s create a &lt;code&gt;client&lt;/code&gt;, &lt;code&gt;server&lt;/code&gt;, and &lt;code&gt;protos&lt;/code&gt; folder:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tree -L 1 -d
.
|-- client
|-- protos
`-- server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next up we&amp;rsquo;ll create the proto interface.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://jbrandhorst.com/post/gopherjs-client-grpc-server-1/&#34;&gt;Part 1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Part 1</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server-1/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server-1/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://jbrandhorst.com/post/gopherjs-client-grpc-server/&#34;&gt;go back&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;create-the-protobuf-interface&#34;&gt;Create the protobuf interface&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ll start by creating a folder for the package we want to create. Lets call it &lt;code&gt;server&lt;/code&gt;.
Next we type up a &lt;code&gt;.proto&lt;/code&gt; file to define the interface between the server and the client.
We&amp;rsquo;ll have to include some extra
&lt;a href=&#34;https://github.com/googleapis/googleapis/blob/f83f68b532d7423f1713d8ec56b16badc0955b6a/google/api/http.proto#L37&#34;&gt;proto annotations&lt;/a&gt; in order to have the gRPC-gateway generate the translations methods we need. Lets define a simple service with a single &lt;code&gt;HTTP GET&lt;/code&gt; endpoint:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;service MyServer {
    rpc Simple(google.protobuf.Empty) returns (MyMessage) {
        option (google.api.http) = {
            get: &amp;quot;/api/v1/simple&amp;quot;
        };
    }
}

message MyMessage {
    string msg = 1;
    uint32 num = 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a new endpoint, &lt;code&gt;Simple&lt;/code&gt;, with takes a &lt;code&gt;google.protobuf.Empty&lt;/code&gt; type as input
(that is, no input), and returns a &lt;code&gt;MyMessage&lt;/code&gt; type. From this, the gRPC-gateway will generate
an endpoint that translates a &lt;code&gt;HTTP GET&lt;/code&gt; on &lt;code&gt;/api/v1/simple&lt;/code&gt; to a gRPC call to the &lt;code&gt;Simple&lt;/code&gt;
function, translating the returned data (or error) back to HTTP. If you&amp;rsquo;re interested in how
gRPC errors are translated to HTTP Status codes, you can take a look at
&lt;a href=&#34;https://github.com/grpc-ecosystem/grpc-gateway/blob/2ad234c172af14e85f3be9546f6c64c768d4eccd/runtime/errors.go&#34;&gt;the grpc-gateway source&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lets make things a bit more interesting and throw in a couple of streaming endpoints as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;service MyServer {
    ...
    rpc Unary(google.protobuf.Empty) returns (stream MyMessage) {
        option (google.api.http) = {
            get: &amp;quot;/api/v1/unary&amp;quot;
        };
    }
    rpc Bidi(stream MyMessage) returns (stream MyMessage) {
        option (google.api.http) = {
            get: &amp;quot;/api/v1/bidi&amp;quot;
        };
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The streaming endpoints are a bit more complicated, as they don&amp;rsquo;t readily translate to
the simple HTTP methods. Unary streaming functions are supported by the gRPC-gateway,
as we&amp;rsquo;ll see when we implement the client. Bi-directional streaming is not (currently!)
supported natively by the gRPC-gateway, but it can be remedied by wrapping the gRPC-gateway
mux in the &lt;a href=&#34;https://github.com/tmc/grpc-websocket-proxy&#34;&gt;grpc-websocket-proxy&lt;/a&gt;. This
allows us to use websockets from the client in order to consume bidi endpoints.&lt;/p&gt;

&lt;p&gt;The complete protobuf file (with imports and options) can be viewed
&lt;a href=&#34;https://github.com/johanbrandhorst/gopherjs-grpc-websocket/blob/5aa1d17633c077a52a48393a4d8678a187e43a12/protos/server/server.proto&#34;&gt;on github&lt;/a&gt;.
Now that we&amp;rsquo;ve got the protobuf interface defined we&amp;rsquo;ll just need to generate the
files that we&amp;rsquo;ll interface with in the Go code. We&amp;rsquo;ll whip out our trusty &lt;code&gt;protoc&lt;/code&gt; compiler
and run it with the Go, gRPC-gateway and
&lt;a href=&#34;https://github.com/johanbrandhorst/protoc-gen-gopherjs&#34;&gt;gopherjs&lt;/a&gt; plugins:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ protoc protos/server/server.proto \
    # Generate Go gRPC stubs.
    # Output is relative to the go_package option,
    # hence the reference to $GOPATH/src.
    --go_out=plugins=grpc:$GOPATH/src \
    # Generate Go gRPC-gateway proxy.
    # Output is relative to file path.
    --grpc-gateway_out=logtostderr=true:./ \
    # Generate GopherJS client structs.
    # Output is relative to file path.
    --gopherjs_out=:./client \
    # Add include paths (in order of importance)
    -I./ \
    # For google/api/annotations.proto
    -I./vendor/github.com/googleapis/googleapis/ \
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll end up with the files &lt;code&gt;protos/server/server.pb.go&lt;/code&gt;, &lt;code&gt;protos/server/server.pb.gw.go&lt;/code&gt; and &lt;code&gt;client/protos/server/server.pb.gopherjs.go&lt;/code&gt;.
The first two belong to the server, and the last one the client.
Now we&amp;rsquo;re ready to implement the server.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://jbrandhorst.com/post/gopherjs-client-grpc-server-2/&#34;&gt;Part 2&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Part 2</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server-2/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server-2/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://jbrandhorst.com/post/gopherjs-client-grpc-server-1/&#34;&gt;go back&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;implement-the-server&#34;&gt;Implement the server&lt;/h2&gt;

&lt;p&gt;I like to start by creating a struct and write a simple definition that&amp;rsquo;ll
immediately fail to compile.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package server

import (
	&amp;quot;github.com/johanbrandhorst/gopherjs-grpc-websocket/protos/server&amp;quot;
)

type Server struct{}

var _ server.MyServerServer = &amp;amp;Server{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This won&amp;rsquo;t compile, because the &lt;code&gt;Server&lt;/code&gt; struct does not implement the
&lt;code&gt;server.MyServerServer&lt;/code&gt; interface. But it&amp;rsquo;ll also tell us what we&amp;rsquo;ve got
left to implement. So lets implement the server methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (s Server) Simple(ctx context.Context, _ *empty.Empty) (*server.MyMessage, error) {
	return &amp;amp;server.MyMessage{
		Msg: &amp;quot;A simple message&amp;quot;,
	}, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Simple&lt;/code&gt; method gets a simple implementation, returning a simple message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (s Server) Unary(_ *empty.Empty, srv server.MyServer_UnaryServer) error {
	// Send 4 messages
	for i := uint32(0); i &amp;lt; 4; i++ {
		msg := &amp;amp;server.MyMessage{
			Msg: &amp;quot;A unary message&amp;quot;,
			Num: i,
		}

		if err := srv.Send(msg); err != nil {
			return err
		}

		// Sleep to simulate some work
		time.Sleep(time.Second)
	}

	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Unary&lt;/code&gt; method simulates a longer running function that does some work and
periodically replies with some result.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (s Server) Bidi(srv server.MyServer_BidiServer) error {
	for i := uint32(0); ; i++ {
		// Blocks until a message is received
		msg, err := srv.Recv()
		if err != nil {
			if err == io.EOF {
				// Client closed connection
				return nil
			}

			return err
		}

		// Just echo back the message sent,
		// incrementing the counter
		msg.Num = i
		if err := srv.Send(msg); err != nil {
			return err
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Bidi&lt;/code&gt; method listens for any messages sent over the stream and echoes the message back,
incrementing the counter each time. This is a very simple use of the gRPC bidi server, but since
what we&amp;rsquo;re really interested in here is the client implementation, it&amp;rsquo;ll do.&lt;/p&gt;

&lt;p&gt;Now that we&amp;rsquo;re done with the server, we can start looking at the client implementation.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://jbrandhorst.com/post/gopherjs-client-grpc-server-3/&#34;&gt;Part 3&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Part 3</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server-3/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server-3/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://jbrandhorst.com/post/gopherjs-client-grpc-server-2/&#34;&gt;go back&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;implement-the-client&#34;&gt;Implement the client&lt;/h2&gt;

&lt;p&gt;GopherJS can be used in a couple of different ways, and there&amp;rsquo;s a couple of different
bindings to many popular JavaScript frameworks.
The &lt;a href=&#34;https://github.com/gopherjs/gopherjs/wiki/bindings&#34;&gt;GopherJS wiki&lt;/a&gt;
has some great resources.&lt;/p&gt;

&lt;p&gt;I tried a couple of different ones and ended up using the
&lt;a href=&#34;https://github.com/oskca/gopherjs-vue&#34;&gt;VueJS bindings&lt;/a&gt; because it made it easy to
prototype things quickly. I hear &lt;a href=&#34;https://vuejs.org/&#34;&gt;VueJS&lt;/a&gt; works well for many JS
evangelisers out there, but I&amp;rsquo;ve only used it with small projects. It&amp;rsquo;ll do for this
blog post, but in the future I want to try working with
&lt;a href=&#34;https://github.com/myitcv/react&#34;&gt;myitcv&amp;rsquo;s React bindings&lt;/a&gt; and the
&lt;a href=&#34;https://github.com/gopherjs/vecty&#34;&gt;Vecty toolkit&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One of the biggest problems with GopherJS at the moment is it
&lt;a href=&#34;https://github.com/gopherjs/gopherjs/issues/136&#34;&gt;does not have deadcode elimination&lt;/a&gt;.
This can be remedied by avoiding many standard library packages. Throughout this I&amp;rsquo;ve kept
minimizing generated file size a priority, to show that it&amp;rsquo;s possible to implement
fully featured frontend apps with GopherJS without compromising on file size.&lt;/p&gt;

&lt;p&gt;To make things a little saner we&amp;rsquo;ll create a couple of folders again.
Lets add &lt;code&gt;compiled&lt;/code&gt; and &lt;code&gt;html&lt;/code&gt; to the &lt;code&gt;client&lt;/code&gt; folder:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd client &amp;amp;&amp;amp; tree -L 1 -d
.
|-- compiled
|-- html
`-- protos
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we&amp;rsquo;ll define the &lt;code&gt;HTML&lt;/code&gt; of our page. Create &lt;code&gt;index.html&lt;/code&gt; in the &lt;code&gt;html&lt;/code&gt; folder.
It&amp;rsquo;s not supposed to be anything fancy, we just want a skeleton for our GopherJS code.
The full HTML can be found on
&lt;a href=&#34;https://github.com/johanbrandhorst/gopherjs-grpc-websocket/blob/4f15a95d84ed6e60ce70359204ce2a64c3021776/client/html/index.html&#34;&gt;my github&lt;/a&gt;,
but it won&amp;rsquo;t make sense without looking at the GopherJS code!&lt;/p&gt;

&lt;p&gt;Skipping out on some boilerplate, we&amp;rsquo;ll start with the Simple button:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;app&amp;quot; v-cloak&amp;gt;
	&amp;lt;h1&amp;gt;gRPC through gopherjs!&amp;lt;/h1&amp;gt;
	&amp;lt;p&amp;gt;
		&amp;lt;h2&amp;gt;Simple&amp;lt;/h2&amp;gt;
		&amp;lt;button v-if=&amp;quot;!simple_message&amp;quot; @click=&amp;quot;Simple()&amp;quot;&amp;gt;Send GET&amp;lt;/button&amp;gt;
		&amp;lt;div v-if=&amp;quot;simple_message&amp;quot;&amp;gt;
			Message: {{ simple_message.msg }}, Num: {{ simple_message.num }}
		&amp;lt;/div&amp;gt;
	&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script src=&amp;quot;index.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a button with the label &lt;code&gt;Send GET&lt;/code&gt;, that will, when clicked, call the
function &lt;code&gt;Simple&lt;/code&gt;. There&amp;rsquo;s also all kinds of references to things we haven&amp;rsquo;t seen yet
so lets move on to the GopherJS code. Again, you can skip ahead and see the full code
on &lt;a href=&#34;https://github.com/johanbrandhorst/gopherjs-grpc-websocket/blob/4f15a95d84ed6e60ce70359204ce2a64c3021776/client/client.go&#34;&gt;my github&lt;/a&gt;. Create &lt;code&gt;client.go&lt;/code&gt; in the &lt;code&gt;client&lt;/code&gt; folder.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

//go:generate gopherjs build -m client.go -o html/index.js
//go:generate go-bindata -pkg compiled -nometadata -o compiled/client.go -prefix html ./html
//go:generate bash -c &amp;quot;rm html/*.js*&amp;quot;

import (
	&amp;quot;github.com/gopherjs/gopherjs/js&amp;quot;
	&amp;quot;github.com/johanbrandhorst/gopherjs-json&amp;quot;
	&amp;quot;github.com/oskca/gopherjs-vue&amp;quot;
	&amp;quot;honnef.co/go/js/xhr&amp;quot;

	&amp;quot;github.com/johanbrandhorst/gopherjs-grpc-websocket/client/helpers&amp;quot;
	&amp;quot;github.com/johanbrandhorst/gopherjs-grpc-websocket/client/protos/server&amp;quot;
)

// Model is the state keeper of the app.
type Model struct {
	*js.Object
	SimpleMessage *server.MyMessage   `js:&amp;quot;simple_message&amp;quot;`
}

func (m *Model) Simple() {
	req := xhr.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;/api/v1/simple&amp;quot;)
	req.SetRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)

	// Wrap call in goroutine to use blocking code
	go func() {
		// Blocks until reply received
		err := req.Send(nil)
		if err != nil {
			panic(err)
		}

		if req.Status != 200 {
			panic(req.ResponseText)
		}

		rObj, err := json.Unmarshal(req.ResponseText)
		if err != nil {
			panic(err)
		}

		msg := &amp;amp;server.MyMessage{
			Object: rObj,
		}

		m.SimpleMessage = msg
	}()
}

func main() {
	m := &amp;amp;Model{
		Object: js.Global.Get(&amp;quot;Object&amp;quot;).New(),
	}

	// These must be set after the struct has been initialised
	// so that the values can be mirrored into the internal JS Object.
	m.SimpleMessage = nil

	// Create the VueJS viewModel using a struct pointer
	vue.New(&amp;quot;#app&amp;quot;, m)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s quite a bit to break down here, so we&amp;rsquo;ll start from the top.&lt;/p&gt;

&lt;p&gt;GopherJS requires packages to pretend that they&amp;rsquo;re binaries,
so we must use &lt;code&gt;package main&lt;/code&gt; at the top.&lt;/p&gt;

&lt;p&gt;Then we&amp;rsquo;ve got a couple of &lt;code&gt;go generate&lt;/code&gt; directives that will create and pack
the JS file so that we can easily serve it from the server later on.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//go:generate gopherjs build -m client.go -o html/index.js
//go:generate go-bindata -pkg compiled -nometadata -o compiled/client.go -prefix html ./html
//go:generate bash -c &amp;quot;rm html/*.js*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first one will compile &lt;code&gt;client.go&lt;/code&gt; file into &lt;code&gt;html/index.js&lt;/code&gt;. The &lt;code&gt;-m&lt;/code&gt;
flag creates a minified JS output file.&lt;/p&gt;

&lt;p&gt;The second one uses the excellent &lt;a href=&#34;https://github.com/jteeuwen/go-bindata&#34;&gt;go-bindata&lt;/a&gt;
to generate a convenience package for serving static content from a
Go webserver. It means we can distribute
a single binary which contains both the webserver logic and the static content.
The &lt;code&gt;-pkg&lt;/code&gt; flag is the name of the package that is generated, the &lt;code&gt;-prefix&lt;/code&gt; flag
removes the specified path from the path in the package. We&amp;rsquo;ll see later how to use it.&lt;/p&gt;

&lt;p&gt;The last one just removes the generated JS file. We do this because all the
data is already in the package we generated in step two and the generated JS
is just a huge unmanageable text file. Who likes looking at JS anyway ;)?&lt;/p&gt;

&lt;p&gt;Next up we&amp;rsquo;ve got the &lt;code&gt;Model&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Model is the state keeper of the app.
type Model struct {
	*js.Object
	SimpleMessage *server.MyMessage   `js:&amp;quot;simple_message&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any Go structs that we want to use with JS need to embed the GopherJS &lt;code&gt;*js.Object&lt;/code&gt; type.
&lt;a href=&#34;https://github.com/gopherjs/gopherjs/wiki/JavaScript-Tips-and-Gotchas&#34;&gt;This is a quirk of GopherJS&lt;/a&gt;,
we&amp;rsquo;ll see more later about what it means.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Model&lt;/code&gt; is required by the &lt;code&gt;VueJS&lt;/code&gt; bindings, and is how we communicate between the Go
world and the &lt;code&gt;HTML&lt;/code&gt;. Anything we assign to properties on the &lt;code&gt;Model&lt;/code&gt; will be reflected
in the &lt;code&gt;HTML&lt;/code&gt; and all methods defined on the &lt;code&gt;Model&lt;/code&gt; are accessible from the &lt;code&gt;HTML&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The definition of &lt;code&gt;*server.MyMessage&lt;/code&gt; is taken from the &lt;code&gt;protoc&lt;/code&gt; Gopherjs plugin
generated file. This is what the definition looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MyMessage struct {
	*js.Object
	Msg string `js:&amp;quot;msg&amp;quot;`
	Num uint32 `js:&amp;quot;num&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;js&lt;/code&gt; struct tag tells GopherJS what the variable should be called in the JS world,
and by extension, in the &lt;code&gt;HTML&lt;/code&gt;. So when we look back at the &lt;code&gt;HTML&lt;/code&gt; we
defined it should now be clearer how things work.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;
	&amp;lt;h2&amp;gt;Simple&amp;lt;/h2&amp;gt;
	&amp;lt;button v-if=&amp;quot;!simple_message&amp;quot; @click=&amp;quot;Simple()&amp;quot;&amp;gt;Send GET&amp;lt;/button&amp;gt;
	&amp;lt;div v-if=&amp;quot;simple_message&amp;quot;&amp;gt;
		Message: {{ simple_message.msg }}, Num: {{ simple_message.num }}
	&amp;lt;/div&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m a little unhappy about keeping logic in the markup, especially when it means using
JS logic, but it&amp;rsquo;ll do for this short introduction. So we show the button if &lt;code&gt;simple_message&lt;/code&gt;
is unpopulated, otherwise we display the contents of the &lt;code&gt;simple_message&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Next up we&amp;rsquo;ve got the definition of the &lt;code&gt;Simple&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (m *Model) Simple() {
	req := xhr.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;/api/v1/simple&amp;quot;)
	req.SetRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)

	// Wrap call in goroutine to use blocking code
	go func() {
		// Blocks until reply received
		err := req.Send(nil)
		if err != nil {
			panic(err)
		}

		if req.Status != 200 {
			panic(req.ResponseText)
		}

		rObj, err := json.Unmarshal(req.ResponseText)
		if err != nil {
			panic(err)
		}

		msg := &amp;amp;server.MyMessage{
			Object: rObj,
		}

		m.SimpleMessage = msg
	}()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll use the excellent &lt;a href=&#34;https://godoc.org/honnef.co/go/js/xhr&#34;&gt;xhr&lt;/a&gt; package for
interacting with the API the server exposes. Using the &lt;code&gt;xhr&lt;/code&gt; library means we can
avoid importing &lt;code&gt;net/http&lt;/code&gt; which adds 3MB to the generated JS file size.&lt;/p&gt;

&lt;p&gt;Another quirk of GopherJS is that blocking code must be wrapped in a goroutine,
this is apparently because JS cannot contain blocking code.
You can find more information about this quirk in the
&lt;a href=&#34;https://github.com/gopherjs/gopherjs#goroutines&#34;&gt;GopherJS README&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As you can probably see, we&amp;rsquo;re using &lt;code&gt;panic&lt;/code&gt; quite liberally in this code,
compared to how it would be used in real Go code. A &lt;code&gt;panic&lt;/code&gt; in GopherJS
will dump the stack to the browser console, which is fine for
something simple like this, but in a real app you might want to capture the
error produced and assign it to something in the &lt;code&gt;Model&lt;/code&gt; to make it visible
to the user.&lt;/p&gt;

&lt;p&gt;Next we use &lt;a href=&#34;https://github.com/johanbrandhorst/gopherjs-json&#34;&gt;a simple json helper library&lt;/a&gt;
to create a GopherJS &lt;code&gt;*js.Object&lt;/code&gt; from the &lt;code&gt;JSON&lt;/code&gt; string the server responds with. Because
we know the &lt;code&gt;JSON&lt;/code&gt; is of the type &lt;code&gt;server.MyMessage&lt;/code&gt;, we can use the &lt;code&gt;*js.Object&lt;/code&gt;
returned to intialise a new &lt;code&gt;server.MyMessage&lt;/code&gt; from the object,
and use that to update the &lt;code&gt;Model&lt;/code&gt;. Simple!&lt;/p&gt;

&lt;p&gt;Lastly we&amp;rsquo;ve got the &lt;code&gt;main&lt;/code&gt; boilerplate:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	m := &amp;amp;Model{
		Object: js.Global.Get(&amp;quot;Object&amp;quot;).New(),
	}

	// These must be set after the struct has been initialised
	// so that the values can be mirrored into the internal JS Object.
	m.SimpleMessage = nil

	// Create the VueJS viewModel using a struct pointer
	vue.New(&amp;quot;#app&amp;quot;, m)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whenever we create a GopherJS struct, a new &lt;code&gt;*js.Object&lt;/code&gt; needs to be assigned to it.
Any properties on the GopherJS structs need to be initialized after the object
has been assigned to it. Note that we must &lt;em&gt;explicitly&lt;/em&gt; initialize properties on
the &lt;code&gt;Model&lt;/code&gt;, in order for the value to be reflected in the underlying
&lt;code&gt;*js.Object&lt;/code&gt;. This is just another quirk of GopherJS.&lt;/p&gt;

&lt;p&gt;We use the &lt;code&gt;VueJS bindings&lt;/code&gt; to create the app. The first parameter is the identifier
of the element in the &lt;code&gt;HTML&lt;/code&gt; which we want to populate the app with.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve got just enough here for a minimal GopherJS frontend to a grpc-gateway proxied
Go gRPC server. But we&amp;rsquo;re still missing the really interesting stuff! Lets implement the
unary streaming function as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;
    &amp;lt;h2&amp;gt;Unary&amp;lt;/h2&amp;gt;
    &amp;lt;button v-if=&amp;quot;unary_messages.length == 0&amp;quot; @click=&amp;quot;Unary()&amp;quot;&amp;gt;Send GET&amp;lt;/button&amp;gt;
    &amp;lt;div v-if=&amp;quot;unary_messages&amp;quot;&amp;gt;
        &amp;lt;div v-for=&amp;quot;msg in unary_messages&amp;quot;&amp;gt;
            Message: {{ msg.msg }}, Num: {{ msg.num }}
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is very similar to the simple one, but we iterate over the messages as they come in.
Next we need to add something to the model, to display the unary messages.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Model struct {
	...
	UnaryMessages []*server.MyMessage `js:&amp;quot;unary_messages&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll need to initialize the new struct member in the &lt;code&gt;main&lt;/code&gt; function as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	...
	m.UnaryMessages = []*server.MyMessage{}
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can implement the &lt;code&gt;Unary&lt;/code&gt; streaming function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func getStreamMessage(msg string) *server.MyMessage {
	rObj, err := json.Unmarshal(msg)
	if err != nil {
		panic(err)
	}

	// The actual message is wrapped in a &amp;quot;result&amp;quot; key,
	// and there might be an error returned as well.
	// See https://github.com/grpc-ecosystem/grpc-gateway/blob/b75dbe36289963caa453a924bd92ddf68c3f2a62/runtime/handler.go#L163
	aux := &amp;amp;struct {
		*js.Object
		msg *server.MyMessage `js:&amp;quot;result&amp;quot;`
	}{
		Object: rObj,
	}

	// The most reliable way I&#39;ve found to check whether
	// an error was returned.
	if rObj.Get(&amp;quot;error&amp;quot;).Bool() {
		panic(msg)
	}

	return aux.msg
}

func (m *Model) Unary() {
	req := xhr.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;/api/v1/unary&amp;quot;)
	req.SetRequestHeader(&amp;quot;cache-control&amp;quot;, &amp;quot;no-cache&amp;quot;)
	req.SetRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)

	bytesRead := 0
	req.AddEventListener(&amp;quot;readystatechange&amp;quot;, false, func(_ *js.Object) {
		switch req.ReadyState {
		case xhr.Loading:
			// This whole dance is because the XHR ResponseText
			// will contain all the messages, and we just want to read
			// anything we havent already read
			resp := req.ResponseText[bytesRead:]
			bytesRead += len(resp)

			m.UnaryMessages = append(m.UnaryMessages, getStreamMessage(resp))
		}
	})

	// Wrap call in goroutine to use blocking code
	go func() {
		// Blocks until reply received
		err := req.Send(nil)
		if err != nil {
			panic(err)
		}

		if req.Status != 200 {
			panic(req.ResponseText)
		}
	}()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While I&amp;rsquo;m quite happy with the overall simplicity of this, unfortunately it&amp;rsquo;s
very much JS in Go clothing. I haven&amp;rsquo;t found a better way to handle periodically
updating requests. Again, the &lt;code&gt;xhr&lt;/code&gt; library makes this much nicer. Unfortunately
the grotesque error check inside the handler is, as far as I can tell, unavoidable.
Hopefully most of the other stuff should be fairly self-explanatory with the comments.&lt;/p&gt;

&lt;p&gt;That leaves us with the bidi-websocket streaming functions left to implement. I wanted
this to show off the capabilities of the websocket protocol, so it&amp;rsquo;s a little more elaborate
than it probably needed to be. This&amp;rsquo;ll be a bit of a code dump but I think most of this
should be reasonable easy to understand, given what we&amp;rsquo;ve talked about so far.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;
	&amp;lt;h2&amp;gt;Bidi&amp;lt;/h2&amp;gt;
	&amp;lt;div v-if=&amp;quot;!ws_conn&amp;quot;&amp;gt;
		&amp;lt;button @click=&amp;quot;Connect()&amp;quot;&amp;gt;Connect to Websocket&amp;lt;/button&amp;gt;
	&amp;lt;/div&amp;gt;
	&amp;lt;form v-if=&amp;quot;ws_conn&amp;quot; v-on:submit.prevent&amp;gt;
		&amp;lt;input type=&amp;quot;text&amp;quot; v-model=&amp;quot;input_message&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
		&amp;lt;button @click=&amp;quot;Send()&amp;quot;&amp;gt;Send Websocket message&amp;lt;/button&amp;gt;
		&amp;lt;button @click=&amp;quot;Close()&amp;quot;&amp;gt;Close Websocket&amp;lt;/button&amp;gt;
	&amp;lt;/form&amp;gt;
	&amp;lt;div v-if=&amp;quot;bidi_messages&amp;quot;&amp;gt;
		&amp;lt;div v-for=&amp;quot;msg in bidi_messages&amp;quot;&amp;gt;
			Message: {{ msg.msg }}, Num: {{ msg.num }}
		&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Model struct {
	...
	InputMessage  string              `js:&amp;quot;input_message&amp;quot;`
	BidiMessages  []*server.MyMessage `js:&amp;quot;bidi_messages&amp;quot;`
	ConnOpen      bool                `js:&amp;quot;ws_conn&amp;quot;`
}

func main() {
	...
	m.BidiMessages = []*server.MyMessage{}
	m.InputMessage = &amp;quot;&amp;quot;
	m.ConnOpen = false
	...
}

// GetWSBaseURL constructs the base URL for WebSocket calls
// Copied from
// https://github.com/gopherjs/websocket/blob/edfe1438a4184bea0b3f9e35fd77969061676d9c/test/test/index.go
func GetWSBaseURL() string {
	document := js.Global.Get(&amp;quot;window&amp;quot;).Get(&amp;quot;document&amp;quot;)
	location := document.Get(&amp;quot;location&amp;quot;)

	wsProtocol := &amp;quot;ws&amp;quot;
	if location.Get(&amp;quot;protocol&amp;quot;).String() == &amp;quot;https:&amp;quot; {
		wsProtocol = &amp;quot;wss&amp;quot;
	}

	return wsProtocol + &amp;quot;://&amp;quot; + location.Get(&amp;quot;hostname&amp;quot;).String() + &amp;quot;:&amp;quot; + location.Get(&amp;quot;port&amp;quot;).String()
}

func (m *Model) Connect() {
	// Wrap call in goroutine to use blocking code
	go func() {
		// Blocks until connection is established
		var err error
		WSConn, err = websocket.Dial(GetWSBaseURL() + &amp;quot;/api/v1/bidi&amp;quot;)
		if err != nil {
			panic(err)
		}

		m.ConnOpen = true
	}()
}

func (m *Model) Close() {
	err := WSConn.Close()
	if err != nil {
		panic(err)
	}

	m.ConnOpen = false
	m.InputMessage = &amp;quot;&amp;quot;
	m.BidiMessages = []*server.MyMessage{}
}

func (m *Model) Send() {
	msg := &amp;amp;server.MyMessage{
		Object: js.Global.Get(&amp;quot;Object&amp;quot;).New(),
	}
	msg.Msg = m.InputMessage
	s, err := json.Marshal(msg.Object)
	if err != nil {
		panic(err)
	}

	_, err = WSConn.Write([]byte(s))
	if err != nil {
		panic(err)
	}

	buf := make([]byte, 1024)
	// Wrap call in goroutine to use blocking code
	go func() {
		// Blocks until a WebSocket frame is received
		n, err := WSConn.Read(buf)
		if err != nil {
			panic(err)
		}

		m.BidiMessages = append(m.BidiMessages, getStreamMessage(string(buf[:n])))
	}()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this, we have separate functions for connecting to the WebSocket,
sending and reading a message, and closing the WebSocket. We use another
excellent GopherJS package, the &lt;a href=&#34;https://github.com/gopherjs/websocket&#34;&gt;websocket&lt;/a&gt;
wrapper for working with the browsers native websockets. The &lt;code&gt;Send&lt;/code&gt; function
takes the text from the form input, marshals it to JSON and sends it on the websocket.
It then reads until it gets a reply. Obviously this can be designed differently
if we need different behaviour.&lt;/p&gt;

&lt;p&gt;Now that we&amp;rsquo;ve finished the client, we need to put everything together.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://jbrandhorst.com/post/gopherjs-client-grpc-server-4/&#34;&gt;Part 4&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GopherJS Client and gRPC Server - Part 4</title>
      <link>https://jbrandhorst.com/post/gopherjs-client-grpc-server-4/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/gopherjs-client-grpc-server-4/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://jbrandhorst.com/post/gopherjs-client-grpc-server-3/&#34;&gt;go back&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;putting-it-all-together&#34;&gt;Putting it all together&lt;/h2&gt;

&lt;p&gt;As we touched upon earlier, we generate a package from the generated JS
(meta, right?), which can be served from the server. We&amp;rsquo;ll create a new
file, &lt;code&gt;main.go&lt;/code&gt;, in which we can spin up a server, serve the frontend
and the gRPC backend.&lt;/p&gt;

&lt;p&gt;Much of the logic in this file is inspired by the
&lt;a href=&#34;https://coreos.com/blog/grpc-protobufs-swagger.html&#34;&gt;excellent blog post put together by Brandon Philips&lt;/a&gt;
over at CoreOS. We&amp;rsquo;re using his elegant solution to serve
both the HTTP API and the gRPC API on the same port.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;crypto/tls&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;os/signal&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;syscall&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;github.com/Sirupsen/logrus&amp;quot;
	assetfs &amp;quot;github.com/elazarl/go-bindata-assetfs&amp;quot;
	&amp;quot;github.com/grpc-ecosystem/grpc-gateway/runtime&amp;quot;
	&amp;quot;github.com/tmc/grpc-websocket-proxy/wsproxy&amp;quot;
	&amp;quot;google.golang.org/grpc&amp;quot;
	&amp;quot;google.golang.org/grpc/credentials&amp;quot;
	&amp;quot;google.golang.org/grpc/grpclog&amp;quot;

	&amp;quot;github.com/johanbrandhorst/gopherjs-grpc-websocket/client/compiled&amp;quot;
	pserver &amp;quot;github.com/johanbrandhorst/gopherjs-grpc-websocket/protos/server&amp;quot;
	&amp;quot;github.com/johanbrandhorst/gopherjs-grpc-websocket/server&amp;quot;
	&amp;quot;github.com/johanbrandhorst/gopherjs-grpc-websocket/server/insecure&amp;quot;
)

// If you change this, you&#39;ll need to change the cert as well
const addr = &amp;quot;localhost:10000&amp;quot;

// Cert and Key should be replaced if you&#39;re going to use this
// Copied from
// https://github.com/philips/grpc-gateway-example/blob/0412e3928cb7d47e68b91971a8e79f93d92361ee/insecure/certs.go
const (
	key = `-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEA2KEH2CLMVmPLGwuExXDUk4TdQInkD0AAe22a1ixKxmRdSXkf
lDKu4cHL0N5ohJBonL/udGWkI6AI51lvJ54zl9SxPoZdWzkdca5H9Cw/7Es3SYyd
eVBkEo341D4hZqpFJM+vPReCQyTCHKGR6XnmN8E9V2RhTKpiagqfSpNmj08Rg3o3
Ap7IzaRRnqmGyKLgJEC2hEXj7nIvHtpm4SCjm2px4bRKQRxREuujOGfqBDh6uYQF
L46PI+QKWDN5J9+fROU9Y0HRFy7JnTkNyTuUxhjB5r2KReQ7cGGpUJzRIyyUDp/u
3+N58AoyQHf/bXpWE0oSfOhwNABVaRWWgxOP2wIDAQABAoIBAEyvtLcummd6rEvG
qBm894PBZRGTvsgnQARxqH5o74+Lt/pqhmNQDdidYiluklFbTa0vxJov4Qs7e+tq
HY9I0brN8HDR3/qLHYFA0Pf/MiHT/p5qyNRJQSPQXmXEGM7fN9rwKnjV+acLPCwm
hiDApl7WaYCmaEtbhbtER19/Dq9sB2vwF2hWvaS8TkpMe6otPVO+3h8MZfrCEQCY
sKpZRJEGaHGX+Oe14NlmO+WhpCR9YXftq5En//zZie5TXiSM596IDriUYf9pWr99
Xeo1JggyrGkQvmGfi5u5qpieX4QBjBKdSqOhiaUKaLQ9T6+mnijp3Cfl/HAkhS5d
RQcmJwECgYEA6+gAvAvPaWxeTY2hiyZfL7trbwJAjrNPxCim6eJJZbhByXnG7oVT
JZQo0pNaE/Exszv0BoaxURKNHM5mU6dEZRgwaiY4UUuKyK2OkSHEu8sOwpXcGI7k
udjEbRaeYBcNAmB25qgisubjbveDJiwK1hbG9T+pSn3E+VotRU2Vk3UCgYEA6xSu
wxSq79llO25O5BQ39DHKfTPeb6KBRdtCIM1L9FQH5CswVQcv1BwqvtvP724cQLkR
5fSQyG5G9qHXmh2dj9pB65h05wlO+F03DP1pQB25QyiogyrWwNmWGnrdsJRo1lAh
pbEWFP+/26n+VtFBcbDcClQsvPL0gOz7hiAuvA8CgYB9SYwKUuNnBAzZd1zSQCDR
guI95J5Qq16zuTtcf7endEJMNIa4asqL7LH5lBSE/tX8cNzbEnHdstKK9/tUdkNW
xZAA8Cd81XfxuGs9HQgVDHTcVya7TDihk0RPA3I9akCYgI7lVWqIRSOI7Z8TiNSA
ezxTR+orC7yvCXt9kQTdeQKBgF2z+dFCzLwcMJDW8FVThdYtfqQXZ8Ohx9ubgSlo
C62RTS/y0yohWjw3GgbHwYOTpWlbG7pImOl7o4etjS4ePe7YNcx+EaMB/9tZ9JaV
8D0hW/ZcH4dhLQbj9EQL05AOKBe9CxxrkPy/0K7zfLEIagiyUZNAaDDMuw8k50FY
VKibAoGAMLZlWDtCHA4J5GhLqRFzOzt2I650EOu/kNhGtJ/8YybgtMVaoN50PGfk
Dr7+TS/DxJzY7h0yNakDg6KZKT4U4qLh74VFaHCnADyQfQnJK+1ffhNhdeoSzp+L
zpDUVEXH6eEeRWmyxoWjWnsquube0gRKf2BQ+yYjk+CUwL/Aqk4=
-----END RSA PRIVATE KEY-----`
	cert = `-----BEGIN CERTIFICATE-----
MIIEBjCCAu6gAwIBAgIJALzaDcEdLBD7MA0GCSqGSIb3DQEBBQUAMF8xCzAJBgNV
BAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBX
aWRnaXRzIFB0eSBMdGQxGDAWBgNVBAMTD2xvY2FsaG9zdDoxMDAwMDAeFw0xNjAy
MTgwMzU5NDJaFw0yNjAyMTUwMzU5NDJaMF8xCzAJBgNVBAYTAkFVMRMwEQYDVQQI
EwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQx
GDAWBgNVBAMTD2xvY2FsaG9zdDoxMDAwMDCCASIwDQYJKoZIhvcNAQEBBQADggEP
ADCCAQoCggEBANihB9gizFZjyxsLhMVw1JOE3UCJ5A9AAHttmtYsSsZkXUl5H5Qy
ruHBy9DeaISQaJy/7nRlpCOgCOdZbyeeM5fUsT6GXVs5HXGuR/QsP+xLN0mMnXlQ
ZBKN+NQ+IWaqRSTPrz0XgkMkwhyhkel55jfBPVdkYUyqYmoKn0qTZo9PEYN6NwKe
yM2kUZ6phsii4CRAtoRF4+5yLx7aZuEgo5tqceG0SkEcURLrozhn6gQ4ermEBS+O
jyPkClgzeSffn0TlPWNB0RcuyZ05Dck7lMYYwea9ikXkO3BhqVCc0SMslA6f7t/j
efAKMkB3/216VhNKEnzocDQAVWkVloMTj9sCAwEAAaOBxDCBwTAdBgNVHQ4EFgQU
7JqKxmk2/4aClcix32bvTr0MUkQwgZEGA1UdIwSBiTCBhoAU7JqKxmk2/4aClcix
32bvTr0MUkShY6RhMF8xCzAJBgNVBAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0YXRl
MSEwHwYDVQQKExhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQxGDAWBgNVBAMTD2xv
Y2FsaG9zdDoxMDAwMIIJALzaDcEdLBD7MAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcN
AQEFBQADggEBAGo0MdEPAV6EH2mhIXBJb6qjg7X0kGqmh10UzmNc/r4N0lcfoPc3
q91N3tAk2zxASW16FPumd3eRtn5FdEWLTK2SAJkP24g6199pUbcEvzHas5/awRI3
PFwNJ+cqsYkXxsW09/cvRBFqMqrkavvoMfCwQhMJwGnql+BeN4mBS00JglHWSfDT
e8T2yhkPc0+FuAH4ZfmdZUb+yPAv+liT+lCw+vUEsN8mnam8lZKCzhROVfmgKEHM
Ze0aj9tzK3Su1tjAEzN4arrajCopkJA2aDI2i8EZ+2Zx1qbhNXwJd3E9MYs9WmLf
RX7r0aSW3Y9r+/SmjYJLXB36CwbcjLHmQN0=
-----END CERTIFICATE-----`
)

var (
	KeyPair  *tls.Certificate
	CertPool *x509.CertPool
	logger *logrus.Logger
)

func init() {
	var err error
	pair, err := tls.X509KeyPair([]byte(cert), []byte(key))
	if err != nil {
		panic(err)
	}
	KeyPair = &amp;amp;pair
	CertPool = x509.NewCertPool()
	ok := CertPool.AppendCertsFromPEM([]byte(cert))
	if !ok {
		panic(&amp;quot;bad certs&amp;quot;)
	}
	logger = logrus.StandardLogger()
	logrus.SetLevel(logrus.InfoLevel)
	logrus.SetFormatter(&amp;amp;logrus.TextFormatter{
		ForceColors:     true,
		FullTimestamp:   true,
		TimestampFormat: time.Kitchen,
		DisableSorting:  true,
	})
	grpclog.SetLogger(logger)
}

func main() {
	s := &amp;amp;server.Server{}

	gs := grpc.NewServer(grpc.Creds(credentials.NewServerTLSFromCert(KeyPair)))
	pserver.RegisterMyServerServer(gs, s)
	conn, err := net.Listen(&amp;quot;tcp&amp;quot;, addr)
	if err != nil {
		logger.WithError(err).Fatal(&amp;quot;Failed to start listener&amp;quot;)
	}

	// Create a context for easy cancellation
	ctx, cancelFunc := context.WithCancel(context.Background())
	defer cancelFunc()

	// Gracefully shut down on ctrl-c
	c := make(chan os.Signal, 1)
	signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		&amp;lt;-c
		go cancelFunc()
		go gs.GracefulStop()
		go conn.Close()
	}()

	mux := http.NewServeMux()

	// Serve the gopherjs client
	mux.Handle(&amp;quot;/&amp;quot;, http.FileServer(&amp;amp;assetfs.AssetFS{
		Asset:     compiled.Asset,
		AssetDir:  compiled.AssetDir,
		AssetInfo: compiled.AssetInfo,
	}))

	gwMux := runtime.NewServeMux(
		runtime.WithMarshalerOption(runtime.MIMEWildcard, &amp;amp;runtime.JSONPb{
			EmitDefaults: true,
			OrigName:     true,
		}),
	)
	// Wrap the gateway in the websocket proxy for bidi streams!
	mux.Handle(&amp;quot;/api/&amp;quot;, wsproxy.WebsocketProxy(gwMux))

	dcreds := credentials.NewTLS(&amp;amp;tls.Config{
		ServerName: addr,
		RootCAs:    CertPool,
	})
	dopts := []grpc.DialOption{grpc.WithTransportCredentials(dcreds)}
	err = pserver.RegisterMyServerHandlerFromEndpoint(ctx, gwMux, addr, dopts)
	if err != nil {
		logger.WithError(err).Fatal(&amp;quot;Failed to dial server&amp;quot;)
	}

	srv := &amp;amp;http.Server{
		Addr:    addr,
		Handler: grpcHandlerFunc(gs, mux),
		TLSConfig: &amp;amp;tls.Config{
			NextProtos:   []string{&amp;quot;h2&amp;quot;},
			Certificates: []tls.Certificate{*KeyPair},
		},
	}

	logger.Warn(&amp;quot;Serving on &amp;quot;, addr)
	logger.Fatal(srv.Serve(tls.NewListener(conn, srv.TLSConfig)))
}

// GrpcHandlerFunc returns an http.Handler that delegates to grpcServer on incoming gRPC
// connections or otherHandler otherwise. Copied from cockroachdb.
func grpcHandlerFunc(grpcServer http.Handler, otherHandler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// This is a partial recreation of gRPC&#39;s internal checks https://github.com/grpc/grpc-go/pull/514/files#diff-95e9a25b738459a2d3030e1e6fa2a718R61
		if r.ProtoMajor == 2 &amp;amp;&amp;amp; strings.Contains(r.Header.Get(&amp;quot;Content-Type&amp;quot;), &amp;quot;application/grpc&amp;quot;) {
			grpcServer.ServeHTTP(w, r)
		} else {
			otherHandler.ServeHTTP(w, r)
		}
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most of this is basic boilerplate when setting up a Go gRPC server, but there&amp;rsquo;s a couple of
things I want to draw attention to.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Serve the gopherjs client
mux.Handle(&amp;quot;/&amp;quot;, http.FileServer(&amp;amp;assetfs.AssetFS{
	Asset:     compiled.Asset,
	AssetDir:  compiled.AssetDir,
	AssetInfo: compiled.AssetInfo,
}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the magic that serves the GopherJS generated JS (and the &lt;code&gt;HTML&lt;/code&gt;). Thanks to
&lt;code&gt;go-bindata&lt;/code&gt; we can just import the package and register it as a file server.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;gwMux := runtime.NewServeMux(
	runtime.WithMarshalerOption(runtime.MIMEWildcard, &amp;amp;runtime.JSONPb{
		EmitDefaults: true,
		OrigName:     true,
	}),
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a new &lt;code&gt;gRPC-gateway&lt;/code&gt; mux, but with a custom JSON marshaler which always
marshals all values of the struct into the &lt;code&gt;JSON&lt;/code&gt;. This is not default behaviour, because
it means the client (frontend) can&amp;rsquo;t tell the difference between when a value was not set
and when it was set to the zero value of that type. We add it because I think it&amp;rsquo;s mostly
expected of real REST APIs to always return all fields.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Wrap the gateway in the websocket proxy for bidi streams!
mux.Handle(&amp;quot;/api/&amp;quot;, wsproxy.WebsocketProxy(gwMux))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This magic is what makes it possible for our &lt;code&gt;grpc-gateway&lt;/code&gt; to handle bidi streams
through websockets, thanks to the work of &lt;a href=&#34;https://github.com/tmc&#34;&gt;tmc&lt;/a&gt; and his library
&lt;a href=&#34;https://github.com/tmc/grpc-websocket-proxy&#34;&gt;grpc-websocket-proxy&lt;/a&gt;. It&amp;rsquo;s a lovely
little wrapper and I encourage you to take a look at it to understand how it works.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// GrpcHandlerFunc returns an http.Handler that delegates to grpcServer on incoming gRPC
// connections or otherHandler otherwise. Copied from cockroachdb.
func grpcHandlerFunc(grpcServer http.Handler, otherHandler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// This is a partial recreation of gRPC&#39;s internal checks https://github.com/grpc/grpc-go/pull/514/files#diff-95e9a25b738459a2d3030e1e6fa2a718R61
		if r.ProtoMajor == 2 &amp;amp;&amp;amp; strings.Contains(r.Header.Get(&amp;quot;Content-Type&amp;quot;), &amp;quot;application/grpc&amp;quot;) {
			grpcServer.ServeHTTP(w, r)
		} else {
			otherHandler.ServeHTTP(w, r)
		}
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is what allows us to serve the gRPC and HTTP API on the same port. A simple
handler for splitting the gRPC requests from the rest. Pretty cool!&lt;/p&gt;

&lt;p&gt;Now with all the puzzle pieces together we should be able to just generate the JS once
and run the server!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go generate ./client/...
$ go run main.go
WARN[7:31PM] Serving on https://localhost:10000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now hopefully if we navigate to &lt;a href=&#34;https://localhost:10000&#34;&gt;https://localhost:10000&lt;/a&gt; in
a browser we&amp;rsquo;ll be greeted by our website. And that&amp;rsquo;s it!&lt;/p&gt;

&lt;h2 id=&#34;final-thoughts&#34;&gt;Final thoughts&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;GopherJS&lt;/code&gt; is cool, &lt;code&gt;gRPC&lt;/code&gt; is great, the &lt;code&gt;gRPC-gateway&lt;/code&gt; is awesome, and
the &lt;code&gt;grpc-websocket-proxy&lt;/code&gt; is amazing. With these tools put together
we&amp;rsquo;ve shown that it&amp;rsquo;s possible to use all the features of modern
browsers while still writing Go. I&amp;rsquo;m going to continue playing around
with &lt;code&gt;GopherJS&lt;/code&gt; and undoubtedly continue to use &lt;code&gt;gRPC&lt;/code&gt; at work.&lt;/p&gt;

&lt;p&gt;Again, to see the whole example in one place, please check out
&lt;a href=&#34;https://github.com/johanbrandhorst/gopherjs-grpc-websocket&#34;&gt;my github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I hope you&amp;rsquo;ve enjoyed reading this, and if you have any feedback or questions,
please contact me on gophers slack or via &lt;a href=&#34;https://twitter.com/JohanBrandhorst&#34;&gt;my twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://jbrandhorst.com/post/gopherjs-client-grpc-server/&#34;&gt;Introduction&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Protobuf Tips</title>
      <link>https://jbrandhorst.com/post/go-protobuf-tips/</link>
      <pubDate>Sun, 16 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jbrandhorst.com/post/go-protobuf-tips/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve had my fair share of dealing with proto files in go (and to some extent JS),
so I thought I&amp;rsquo;d share some stuff I&amp;rsquo;ve learnt the hard way by working
with proto files.&lt;/p&gt;

&lt;h2 id=&#34;protoc-include-paths&#34;&gt;Protoc include paths&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;protoc&lt;/code&gt; include paths can be pretty confusing, so I&amp;rsquo;ll give a few examples
of how to use it properly.&lt;/p&gt;

&lt;h4 id=&#34;just-include-the-current-directory&#34;&gt;Just include the current directory&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;protoc&lt;/code&gt; requires that the files referenced are in the include path, so if you&amp;rsquo;re
referencing files relative to the current directory, you&amp;rsquo;ll need to specify &lt;code&gt;-I.&lt;/code&gt;,
which also means the &lt;code&gt;protoc&lt;/code&gt; will resolve
all proto import paths relative to the current directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ protoc myproto/myproto.proto -I. --go_out=:.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As long as your proto file imports are all relative to the current directory, this will work.&lt;/p&gt;

&lt;h4 id=&#34;several-include-paths&#34;&gt;Several include paths&lt;/h4&gt;

&lt;p&gt;If you&amp;rsquo;re using the &lt;a href=&#34;https://github.com/grpc-ecosystem/grpc-gateway&#34;&gt;grpc-gateway&lt;/a&gt;
you&amp;rsquo;ll have to include the &lt;code&gt;google/api/annotations.proto&lt;/code&gt; proto file.
The way I&amp;rsquo;ve always done that is by vendoring the proto files and adding the vendor path
as an include path:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ protoc myproto/myproto.proto -I. -I./vendor/github.com/googleapis/googleapis/ --go_out=:.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Includes are specified in order of priority, so &lt;code&gt;protoc&lt;/code&gt; will first see if
&lt;code&gt;./google/api/annotations.proto&lt;/code&gt; exists, and if it doesn&amp;rsquo;t, it&amp;rsquo;ll check
&lt;code&gt;./vendor/github.com/googleapis/googleapis/google/api/annotations.proto&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that vendoring is obviously a Go thing, so this might not chime well
with the other Devs in the office who want to keep the proto repository language agnostic.
In that case, you&amp;rsquo;ll probably define some &lt;code&gt;third_party&lt;/code&gt; folder where you can put
the external dependencies.&lt;/p&gt;

&lt;h2 id=&#34;use-the-go-package-option&#34;&gt;Use the &lt;code&gt;go_package&lt;/code&gt; option&lt;/h2&gt;

&lt;p&gt;This isn&amp;rsquo;t something readily advertised in the
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/gotutorial&#34;&gt;introduction to protobuffers in Go&lt;/a&gt;
or &lt;a href=&#34;http://www.grpc.io/docs/quickstart/go.html&#34;&gt;Go gRPC quick start&lt;/a&gt;, but I find it
is essential if you ever want to import proto definitions from one proto file to another.&lt;/p&gt;

&lt;h4 id=&#34;raison-d-tre&#34;&gt;Raison d&amp;rsquo;tre&lt;/h4&gt;

&lt;p&gt;For example, lets say we have &lt;code&gt;person.proto&lt;/code&gt; in &lt;code&gt;person/person.proto&lt;/code&gt;. It defines the
proto package &lt;code&gt;person&lt;/code&gt; and the message &lt;code&gt;Person&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;syntax = &amp;quot;proto3&amp;quot;;

package person;

message Person {
  string Name = 1;
  uint32 Age = 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also have &lt;code&gt;team.proto&lt;/code&gt; in &lt;code&gt;team/team.proto&lt;/code&gt;, defining the proto package
&lt;code&gt;team&lt;/code&gt; and the message &lt;code&gt;Team&lt;/code&gt;. A &lt;code&gt;Team&lt;/code&gt; consists of a sorted list of &lt;code&gt;Person&lt;/code&gt;s,
so &lt;code&gt;team.proto&lt;/code&gt; will need to import that definition from &lt;code&gt;person.proto&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;No problem, just add an &lt;code&gt;import person/person.proto&lt;/code&gt; to &lt;code&gt;team.proto&lt;/code&gt; and reference it
using the namespace specified by the &lt;code&gt;person.proto&lt;/code&gt; package name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;syntax = &amp;quot;proto3&amp;quot;;

package team;

import &amp;quot;person/person.proto&amp;quot;

message Team {
  repeated person.Person people = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we generate a go file from this definition using &lt;code&gt;protoc&lt;/code&gt;, we&amp;rsquo;ll end up with a Go file
that imports &lt;code&gt;person/person.pb.go&lt;/code&gt;. That&amp;rsquo;s no good!&lt;/p&gt;

&lt;p&gt;Enter the &lt;code&gt;go_package&lt;/code&gt; option.&lt;/p&gt;

&lt;h4 id=&#34;using-the-go-package-option&#34;&gt;Using the &lt;code&gt;go_package&lt;/code&gt; option&lt;/h4&gt;

&lt;p&gt;For a proto file defined in &lt;code&gt;github.com/myuser/myprotos/myproto/myproto.proto&lt;/code&gt; the
appropriate &lt;code&gt;go_option&lt;/code&gt; value would be &lt;code&gt;github.com/myuser/myprotos/myproto&lt;/code&gt;.
This means that the &lt;code&gt;protoc&lt;/code&gt; compiler can generate a go file that will include the package
&lt;code&gt;github.com/myuser/myprotos/myproto&lt;/code&gt; if you have another proto file that depends
on &lt;code&gt;myproto/myproto.proto&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s fix the &lt;code&gt;person.proto&lt;/code&gt; and &lt;code&gt;team.proto&lt;/code&gt; proto files.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;syntax = &amp;quot;proto3&amp;quot;;

option go_package = &amp;quot;github.com/myuser/myprotos/person&amp;quot;;

package person;

message Person {
  string Name = 1;
  uint32 Age = 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;syntax = &amp;quot;proto3&amp;quot;;

option go_package = &amp;quot;github.com/myuser/myprotos/team&amp;quot;;

package team;

import &amp;quot;person/person.proto&amp;quot;

message Team {
  repeated person.Person members = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, you might say we don&amp;rsquo;t strictly &lt;em&gt;need&lt;/em&gt; to specify the &lt;code&gt;go_package&lt;/code&gt; for &lt;code&gt;team.proto&lt;/code&gt;,
since nothing imports it at the minute. I&amp;rsquo;d still suggest adding it to all the proto files
that you&amp;rsquo;ll generate go code from so that in the future when a dependency might arise, you&amp;rsquo;ve
saved yourself, or even better, someone else, a whole lot of head scratching.&lt;/p&gt;

&lt;h4 id=&#34;protoc-gen-go-output-paths-with-go-package-option&#34;&gt;&lt;code&gt;protoc-gen-go&lt;/code&gt; output paths with &lt;code&gt;go_package&lt;/code&gt; option&lt;/h4&gt;

&lt;p&gt;One final note on the &lt;code&gt;go_package&lt;/code&gt; option. Specifying it in your proto file means the
&lt;code&gt;protoc-gen-go&lt;/code&gt; &lt;code&gt;protoc&lt;/code&gt; plugin outputs your generated files as if the specified output directory is at the root of the &lt;code&gt;go_package&lt;/code&gt; path. So&amp;hellip; you&amp;rsquo;ll probably want to slightly modify your &lt;code&gt;protoc&lt;/code&gt; line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;protoc person/person.proto team/team.proto -I. --go_out=:$GOPATH/src
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should mean the files appear where you expect them to appear. Mind you make sure there
are no typos in the &lt;code&gt;go_package&lt;/code&gt; option as it means the files will be generated in wrong place.&lt;/p&gt;

&lt;h2 id=&#34;protoc-plugin-parameters&#34;&gt;&lt;code&gt;protoc&lt;/code&gt; plugin parameters&lt;/h2&gt;

&lt;p&gt;Another thing I&amp;rsquo;ve learned through hours staring at my terminal in bewilderment is
how parameters are passed to &lt;code&gt;protoc&lt;/code&gt; plugins. For example, the &lt;code&gt;protoc-gen-go&lt;/code&gt; plugin
allows you to specify &lt;code&gt;plugin=grpc&lt;/code&gt; as a parameter, and the &lt;code&gt;protoc-gen-grpc-gateway&lt;/code&gt; takes
a boolean parameter &lt;code&gt;logtostderr=true&lt;/code&gt;. I also think the &lt;code&gt;M&lt;/code&gt; parameter is a &lt;code&gt;protoc&lt;/code&gt;-wide way
to change the import path of a specific import as defined in a proto file. Parameters are
comma (&lt;code&gt;,&lt;/code&gt;) separated. Parameter specification is delimited by the colon (&lt;code&gt;:&lt;/code&gt;) character,
after which comes the desired output path.
The following are all valid &lt;code&gt;protoc&lt;/code&gt; commands illustrating this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ protoc myproto/myproto.proto -I. --go_out=plugin=grpc:.
$ protoc myproto/myproto.proto -I. --grpc-gateway_out=logtostderr=true,Mgoogle/api/annotations.proto=myrepo/api/annotations.proto:.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;more&#34;&gt;More&lt;/h2&gt;

&lt;p&gt;Feel free to reach out to me on gophers slack or on
&lt;a href=&#34;https://twitter.com/JohanBrandhorst&#34;&gt;my twitter&lt;/a&gt; if you found this helpful or if you have
any more tips I should include in this list.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>